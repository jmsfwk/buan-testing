<?php

namespace Buan\Testing\Factories;

use Buan\Model;
use Buan\ModelCollection;
use Buan\Testing\Str;
use Closure;
use Faker\Generator;

abstract class Factory
{
    /**
     * The name of the factory's corresponding model.
     *
     * @var string
     */
    protected $model;

    /**
     * The number of models that should be generated.
     *
     * @var int|null
     */
    protected $count;

    /**
     * The state transformations that will be applied to the model.
     *
     * @var callable[]
     */
    protected $states;

    /**
     * The parent relationships that will be applied to the model.
     *
     * @var Relationship[]
     */
    protected $has;

    /**
     * The child relationships that will be applied to the model.
     *
     * @var array
     */
    protected $for;

    /**
     * The "after making" callbacks that will be applied to the model.
     *
     * @var Closure[]
     */
    protected $afterMaking;

    /**
     * The "after creating" callbacks that will be applied to the model.
     *
     * @var Closure[]
     */
    protected $afterCreating;

    /**
     * The name of the database connection that will be used to create the models.
     *
     * @var string
     */
    protected $connection;

    /**
     * The current Faker instance.
     *
     * @var \Faker\Generator
     */
    protected $faker;

    /**
     * The default namespace where factories reside.
     *
     * @var string
     */
    protected static $namespace = 'Database\\Factories\\';

    /**
     * The default model name resolver.
     *
     * @var callable
     */
    protected static $modelNameResolver;

    /**
     * The factory name resolver.
     *
     * @var callable
     */
    protected static $factoryNameResolver;

    /**
     * Create a new factory instance.
     *
     * @param int|null $count
     * @param array $states
     * @param array $has
     * @param array $for
     * @param array $afterMaking
     * @param array $afterCreating
     * @param string $connection
     * @return void
     */
    public function __construct(
        $count = null,
        ?array $states = null,
        ?array $has = null,
        ?array $for = null,
        ?array $afterMaking = null,
        ?array $afterCreating = null,
        $connection = null
    ) {
        $this->count = $count;
        $this->states = $states ?: [];
        $this->has = $has ?: [];
        $this->for = $for ?: [];
        $this->afterMaking = $afterMaking ?: [];
        $this->afterCreating = $afterCreating ?: [];
        $this->connection = $connection;
        $this->faker = $this->withFaker();
    }

    /**
     * Define the model's default state.
     */
    abstract public function definition(): array;

    /**
     * Get a new factory instance for the given attributes.
     *
     * @param callable|array $attributes
     */
    public static function new($attributes = []): self
    {
        return (new static)->state($attributes)->configure();
    }

    /**
     * Get a new factory instance for the given number of models.
     *
     * @param int $count
     */
    public static function times(int $count): self
    {
        return static::new()->count($count);
    }

    /**
     * Configure the factory.
     *
     * @return $this
     */
    public function configure(): self
    {
        return $this;
    }

    /**
     * Get the raw attributes generated by the factory.
     *
     * @param array $attributes
     * @param \Buan\Model|null $parent
     */
    public function raw(array $attributes = [], ?Model $parent = null): array
    {
        return $this->state($attributes)->getExpandedAttributes($parent);
    }

    /**
     * Create a single model and persist it to the database.
     *
     * @param array $attributes
     */
    public function createOne(array $attributes = []): Model
    {
        return $this->count(null)->create($attributes);
    }

    /**
     * Create a collection of models and persist them to the database.
     *
     * @param iterable $records
     * @return \Buan\ModelCollection|mixed
     */
    public function createMany(iterable $records)
    {
        return new ModelCollection(
            array_map(function ($record) {
                return $this->state($record)->create();
            }, $records)
        );
    }

    /**
     * Create a collection of models and persist them to the database.
     *
     * @param array $attributes
     * @param \Buan\Model|null $parent
     * @return \Buan\ModelCollection|\buan\Model|mixed
     */
    public function create(array $attributes = [], ?Model $parent = null)
    {
        if (!empty($attributes)) {
            return $this->state($attributes)->create([], $parent);
        }

        $results = $this->make($attributes, $parent);

        if ($results instanceof Model) {
            $this->store([$results]);

            $this->callAfterCreating([$results], $parent);
        } else {
            $this->store($results);

            $this->callAfterCreating($results, $parent);
        }

        return $results;
    }

    /**
     * Set the connection name on the results and store them.
     *
     * @param iterable $results
     */
    protected function store(iterable $results): void
    {
        foreach ($results as $model) {
            $model->save();

            $this->createChildren($model);
        }
    }


    /**
     * Create the children for the given model.
     */
    protected function createChildren(Model $model): void
    {
        foreach ($this->has as $has) {
            $has->createFor($model);
        }
    }

    /**
     * Make a single instance of the model.
     *
     * @param callable|array $attributes
     */
    public function makeOne($attributes = []): Model
    {
        return $this->count(null)->make($attributes);
    }

    /**
     * Create a collection of models.
     *
     * @param array $attributes
     * @param \Buan\Model|null $parent
     * @return \Buan\ModelCollection|\Buan\Model|mixed
     */
    public function make(array $attributes = [], ?Model $parent = null)
    {
        if (!empty($attributes)) {
            return $this->state($attributes)->make([], $parent);
        }

        if ($this->count === null) {
            return self::tap($this->makeInstance($parent), function ($instance) {
                $this->callAfterMaking([$instance]);
            });
        }

        if ($this->count < 1) {
            return new ModelCollection();
        }

        $instances = new ModelCollection(array_map(function () use ($parent) {
            return $this->makeInstance($parent);
        }, range(1, $this->count)));

        $this->callAfterMaking($instances);

        return $instances;
    }

    /**
     * Make an instance of the model with the given attributes.
     */
    protected function makeInstance(?Model $parent): Model
    {
        return $this->newModel($this->getExpandedAttributes($parent));
    }

    /**
     * Get a raw attributes array for the model.
     */
    protected function getExpandedAttributes(?Model $parent): array
    {
        return $this->expandAttributes($this->getRawAttributes($parent));
    }

    /**
     * Get the raw attributes for the model as an array.
     */
    protected function getRawAttributes(?Model $parent): array
    {
        $states = !$this->for ? $this->states : array_merge([function () {
            return $this->parentResolvers();
        }], $this->states);

        return array_reduce($states, function ($carry, $state) use ($parent) {
            if ($state instanceof Closure) {
                $state = $state->bindTo($this);
            }

            return array_merge($carry, $state($carry, $parent));
        }, $this->definition());
    }

    /**
     * Create the parent relationship resolvers (as deferred Closures).
     */
    protected function parentResolvers(): array
    {
        $model = $this->newModel();

        return array_merge(...array_map(static function (BelongsToRelationship $for) use ($model) {
            return $for->attributesFor($model);
        }, $this->for));
    }

    /**
     * Expand all attributes to their underlying values.
     */
    protected function expandAttributes(array $definition): array
    {
        return array_map(static function ($attribute) use ($definition) {
            if (is_callable($attribute) && !is_string($attribute) && !is_array($attribute)) {
                $attribute = $attribute($definition);
            }

            if ($attribute instanceof self) {
                $attribute = $attribute->create()->getPrimaryKeyValue();
            } elseif ($attribute instanceof Model) {
                $attribute = $attribute->getPrimaryKeyValue();
            }

            return $attribute;
        }, $definition);
    }

    /**
     * Add a new state transformation to the model definition.
     *
     * @param callable|array $state
     */
    public function state($state): self
    {
        return $this->newInstance([
            'states' => array_merge($this->states, [
                is_callable($state) ? $state : function () use ($state) {
                    return $state;
                },
            ]),
        ]);
    }

    /**
     * Add a new sequenced state transformation to the model definition.
     */
    public function sequence(array ...$sequence): self
    {
        return $this->state(new Sequence(...$sequence));
    }

    /**
     * Define a child relationship for the model.
     */
    public function has(self $factory): self
    {
        return $this->newInstance([
            'has' => array_merge($this->has, [new Relationship($factory)]),
        ]);
    }

    /**
     * Define a parent relationship for the model.
     */
    public function for(self $factory, string $relationship = null): self
    {
        return $this->newInstance([
            'for' => array_merge($this->for, [
                new BelongsToRelationship($factory, $relationship)
            ])
        ]);
    }

    /**
     * Add a new "after making" callback to the model definition.
     */
    public function afterMaking(Closure $callback): self
    {
        return $this->newInstance(['afterMaking' => array_merge($this->afterMaking, [$callback])]);
    }

    /**
     * Add a new "after creating" callback to the model definition.
     */
    public function afterCreating(Closure $callback): self
    {
        return $this->newInstance(['afterCreating' => array_merge($this->afterCreating, [$callback])]);
    }

    /**
     * Call the "after making" callbacks for the given model instances.
     */
    protected function callAfterMaking(iterable $instances): void
    {
        foreach ($instances as $instance) {
            foreach ($this->afterMaking as $callback) {
                $callback($instance);
            }
        }
    }

    /**
     * Call the "after creating" callbacks for the given model instances.
     */
    protected function callAfterCreating(iterable $instances, ?Model $parent = null): void
    {
        foreach ($instances as $instance) {
            foreach ($this->afterCreating as $callback) {
                $callback($instance, $parent);
            }
        }
    }

    /**
     * Specify how many models should be generated.
     */
    public function count(?int $count): self
    {
        return $this->newInstance(['count' => $count]);
    }

    /**
     * Specify the database connection that should be used to generate models.
     */
    public function connection(string $connection): self
    {
        return $this->newInstance(['connection' => $connection]);
    }

    /**
     * Create a new instance of the factory builder with the given mutated properties.
     */
    protected function newInstance(array $arguments = []): self
    {
        return new static(...array_values(array_merge([
            'count' => $this->count,
            'states' => $this->states,
            'has' => $this->has,
            'for' => $this->for,
            'afterMaking' => $this->afterMaking,
            'afterCreating' => $this->afterCreating,
            'connection' => $this->connection,
        ], $arguments)));
    }

    /**
     * Get a new model instance.
     */
    public function newModel(array $attributes = []): Model
    {
        $model = $this->modelName();
        return self::tap(new $model, static function (Model $model) use ($attributes) {
            $model->populateFromArray($attributes);
        });
    }

    /**
     * Get the name of the model that is generated by the factory.
     */
    public function modelName(): string
    {
        $resolver = static::$modelNameResolver ?: static function (self $factory) {
            $name = Str::replaceLast('Factory', '', Str::classBasename($factory));

            return $name.'Model';
        };

        return $this->model ?: $resolver($this);
    }

    /**
     * Specify the callback that should be invoked to guess model names based on factory names.
     */
    public static function guessModelNamesUsing(callable $callback): void
    {
        static::$modelNameResolver = $callback;
    }

    /**
     * Specify the default namespace that contains the application's model factories.
     */
    public static function useNamespace(string $namespace): void
    {
        static::$namespace = $namespace;
    }

    /**
     * Get a new factory instance for the given model name.
     */
    public static function factoryForModel(string $modelName): self
    {
        $factory = static::resolveFactoryName($modelName);

        return call_user_func([$factory, 'new']);
    }

    /**
     * Specify the callback that should be invoked to guess factory names based on dynamic relationship names.
     */
    public static function guessFactoryNamesUsing(callable $callback): void
    {
        static::$factoryNameResolver = $callback;
    }

    /**
     * Get a new Faker instance.
     */
    protected function withFaker(): Generator
    {
        return \Faker\Factory::create('en_GB');
    }

    /**
     * Get the factory name for the given model name.
     */
    public static function resolveFactoryName(string $modelName): string
    {
        $resolver = static::$factoryNameResolver ?: static function (string $modelName) {
            $modelName = Str::beforeLast(Str::classBasename($modelName), 'Model');

            return static::$namespace . $modelName . 'Factory';
        };

        return $resolver($modelName);
    }

    private static function tap($value, Closure $callback)
    {
        $callback($value);

        return $value;
    }
}
